/*
https://www.chessprogramming.org/Magic_Bitboards
*/

use super::Bitboard;
use rand::Rng;
use std::collections::{HashMap, HashSet};
use std::time::Instant;

#[derive(Clone, Default)]
pub struct MagicHashTable {
    /*
    Magic bitboard generation consists of four key steps:
     1. Mask the relevant occupancy bits to form a key. For example if you had a rook on a1, the relevant occupancy bits
        will be from a2-a7 and b1-g1.
     2. Multiply the key by a "magic number" to obtain an index mapping. This magic number can be generated by
        brute-force trial and error quite easily although it isn't 100% certain that the magic number is the best
        possible (see step 3).
     3. Right shift the index mapping by 64-n bits to create an index, where n is the number of bits in the index. A
        better magic number will have less bits required in the index.
     4. Use the index to reference a preinitialized move database.

    NOTE: for speed we can just take `(number of elements in the table).ilog2()` to get a good approximation of the
          best shift value. Further optimization can be done to try and find a smaller shift value but it's not
          necessary.
    */
    pub magic: u64,
    pub n_elements: usize,
    pub table: Vec<Bitboard>,
}

impl MagicHashTable {
    fn custom_hash(key: Bitboard, magic: u64, n_elements: usize) -> usize {
        let hash = (key.wrapping_mul(magic)) >> (64 - n_elements.ilog2());
        hash as usize
    }

    pub fn get(&self, key: Bitboard) -> Bitboard {
        let index = MagicHashTable::custom_hash(key, self.magic, self.n_elements);
        self.table[index]
    }

    pub fn compute_magic_number(blockers_table: HashMap<Bitboard, Bitboard>) -> MagicHashTable {
        let mut rng = rand::thread_rng();

        let mut best_magic = 0;
        let mut best_size = usize::MAX;
        let n_elements = blockers_table.keys().len();

        let start = Instant::now();
        loop {
            let magic = rng.gen::<u64>() & rng.gen::<u64>() & rng.gen::<u64>();

            let mut seen = HashSet::new();
            let mut valid = true;

            for blocker in blockers_table.keys() {
                let index = MagicHashTable::custom_hash(*blocker, magic, n_elements);
                if !seen.insert(index) {
                    valid = false;
                    break;
                }
            }

            let hash_size = *seen.iter().max().unwrap_or(&usize::MAX);
            if valid && hash_size < best_size {
                best_magic = magic;
                best_size = hash_size + 1;
            }

            if best_size == n_elements {
                println!(
                    "Table perfectly hashed with: {{magic: {}, significant bits: {}}} in {:?}",
                    best_magic,
                    n_elements.ilog2(),
                    start.elapsed()
                );
                break;
            }
        }

        let mut table = vec![0; best_size];
        for key in blockers_table.keys() {
            let index = MagicHashTable::custom_hash(*key, best_magic, n_elements);
            let attacks = blockers_table.get(key).unwrap();
            table[index] = *attacks;
        }

        MagicHashTable {
            table,
            n_elements,
            magic: best_magic,
        }
    }
}
